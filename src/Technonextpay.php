<?php

namespace TechnonextPlugin;

use TechnonextPlugin\TechnonextpayValidation;
use TechnonextPlugin\TechnonextpayConfig;

require_once __DIR__ . '/TechnonextpayException.php';
require_once __DIR__ . '/TechnonextpayConfig.php';
require_once __DIR__ . '/TechnonextpayValidation.php';

/**
 * PHP plugin class to connect and integrate with Technonextpay payment gateway API.
 * There are three mandatory public functions which will need to access Technonextpay.<br>
 * 1. paymentOrder()-> authenticat and generates payment url for checkout
 * 3. verifyPayment()-> makes payment verification
 * prepareCurlRequest, prepareTransactionPayload & logInfo() are internally.
 *
 * @author 
 * @since 
 */
class Technonextpay
{
    private $conf;
	private $url_checkout, $url_verify;
    /** Technonextpay payment gateway API endpoint */
    public function __construct(TechnonextpayConfig $config)
    {
        $this->conf = $config;
        $this->url_checkout = $this->conf->api_endpoint . "/payment/api/v1/p/service/api/payment/processing/payment-order";
        $this->url_verify = $this->conf->api_endpoint . "/payment/api/v1/p/service/api/payment/processing/verify";
    }

  
    /** @throws TechnonextpayException */
    public function paymentOrder(PaymentRequest $payload)
    {
        $validation = new TechnonextpayValidation();
        if (!$validation->checkInternetConnection()) {
            exit("Your have no internet connection! Please check your internet connection.");
        }

        $trxn_data = $this->prepareTransactionPayload($payload);
        if (!$validation->Validation($trxn_data))
            throw new TechnonextpayException("Payment data validation failed", 0, null);

        $result = $this->generateSignature(
            $trxn_data,
            $this->conf->api_key,
            $this->conf->merchant_code,      
            $this->conf->api_secret
        );

      
        $header = array(
            'X-TNPG-TIMESTAMP: '.$result['timestamp'],
            'X-TNPG-HOST: '.$this->conf->api_endpoint,
            'X-TNPG-TARGET-API: POST /p/service/api/payment/processing/payment-order',
            'X-TNPG-MERCHANT-ID: '.$this->conf->merchant_code,
            'X-TNPG-API-KEY: '.$this->conf->api_key,
            'X-TNPG-SIGNATURE: ' . $result['signature'],
            'X-TNPG-DIGEST: '.$result['digest'],
            'Content-Type: application/json'
        );


        try {
            $response = $this->getHttpResponse($this->url_checkout, 'POST', $trxn_data, $header);
            if (!empty($response->data->gateway_page_url)) {
                $this->log("Payment URL has been generated by Technonextpay!");
                header('Location: ' . $response->data->gateway_page_url);
                exit;
            } else {
                return $response; //object
            }
        } catch (TechnonextpayException | \BadMethodCallException | \ArgumentCountError | \InvalidArgumentException $e) {
            $this->log("Exception in Technonextpay->paymentOrder" . ". \n" . $e->getMessage());
            throw new TechnonextpayException("Please check and resolve errors to make successful payment", 0, $e);
        }
    }

    /** @throws TechnonextpayException */
    public function verifyPayment($payload)
    {
        $result = $this->generateSignature(
            json_encode(
                array(
                    'paymentOrderId' => $payload->order_tracking_id                  
                )
            ),
            $this->conf->api_key,
            $this->conf->merchant_code,      
            $this->conf->api_secret
        );

        $header = array(
            'X-TNPG-TIMESTAMP: '.$result['timestamp'],
            'X-TNPG-HOST: '.$this->conf->api_endpoint,
            'X-TNPG-TARGET-API: POST /p/service/api/payment/processing/payment-order',
            'X-TNPG-MERCHANT-ID: '.$this->conf->merchant_code,
            'X-TNPG-API-KEY: '.$this->conf->api_key,
            'X-TNPG-SIGNATURE: ' . $result['signature'],
            'X-TNPG-DIGEST: '.$result['digest'],
            'Content-Type: application/json'
        );

        $postFields = json_encode(
            array(
                'paymentOrderId' => $payload->order_tracking_id,
            )
        );

        try {
            $response = $this->getHttpResponse($this->url_verify, 'POST', $postFields, $header);
            $this->log("Payment verification for " . $payload->order_id . " was done successfully");
            return $response;
        } # Catching TechnonextpayException custom exception and throwing it to TechnonextpayException
        catch (TechnonextpayException | \BadMethodCallException | \ArgumentCountError | \InvalidArgumentException $e) {
            $this->log("Exception in Technonextpay->verifyPayment" . ". \n" . $e->getMessage());
            throw new TechnonextpayException("Please check and resolve errors to make successful payment", 0, $e);
        }
    }

    public function prepareTransactionPayload($payload)
    {

        return json_encode(
            array(
                'order_id' => $this->conf->order_prefix . uniqid(),
                'order_information'=> array(
                    'payable_amount' => $payload->payable_amount,
                    'currency_code' => $payload->currency_code
                ),
                'ipn_url' => $this->conf->ipn_url,
                'success_url' => $this->conf->success_url,
                'cancel_url' => $this->conf->cancel_url,
                'failure_url' => $this->conf->failure_url,
                'promotion_information' => array(
                    'preferred_channel' => $payload->preferred_channel,
                    'allowed_bin' => $payload->allowed_bin
                ),
                'customer_information'=> array(
                    'name' => $payload->customer_name,
                    'email' => $payload->customer_email,
                    'primaryAddress' => $payload->customer_primaryAddress,
                    'secondaryAddress' => $payload->customer_secondaryAddress,
                    'contact_number' => $payload->contact_number,
                    'city' => $payload->customer_city,
                    'state' => $payload->customer_state,
                    'postcode' => $payload->customer_postcode,
                    'country' => $payload->customer_country,
                    'fax'=>  $payload->contact_number,
                ),
                'shipping_information' => array(
                    'address_line1' => $payload->shipping_address,
                    'city' => $payload->shipping_city,
                    'country' => $payload->shipping_country,
                ),
                'mdf1' => $payload->mdf1,
                'mdf2' => $payload->mdf2,
                'mdf3' => $payload->mdf3,       
                'mdf4' => $payload->mdf4
            )
        );
    }

    public function getClientIpOrHost()
    {
        if (isset($_SERVER['REMOTE_ADDR']))
            return $_SERVER['REMOTE_ADDR'];
        if (isset($_SERVER['HTTP_X_FORWARDED_FOR']))
            return $_SERVER['HTTP_X_FORWARDED_FOR'];
        if (isset($_SERVER['HTTP_CLIENT_IP']))
            return $_SERVER['HTTP_CLIENT_IP'];
        return gethostname();
    }

    /**
     * Prepare and send HTTP requests using curl library and process response.
     *
     * @param $url Destination URL
     * @param $method POST or GET
     * @param $payload_data
     * @param $header Header options
     * @return mixed
     * @throws TechnonextpayException
     */
    public function getHttpResponse($url, $method, $payload_data, $header)
    {
        $curl = curl_init();

        try {
            curl_setopt_array(
                $curl,
                array(
                    CURLOPT_URL => $url,
                    CURLOPT_HTTPHEADER => $header,
                    CURLOPT_POST => 1,
                    CURLOPT_RETURNTRANSFER => true,
                    CURLOPT_POSTFIELDS => $payload_data,
                    CURLOPT_CUSTOMREQUEST => $method,
                    CURLOPT_ENCODING => '',
                    CURLOPT_MAXREDIRS => 10,
                    CURLOPT_TIMEOUT => 30, // Reasonable timeout
                    CURLOPT_FOLLOWLOCATION => true,
                    CURLOPT_SSL_VERIFYPEER => $this->conf->ssl_verifypeer,
                    CURLOPT_SSL_VERIFYHOST => $this->conf->ssl_verifypeer ? 2 : 0,
                )
            );

            $response = curl_exec($curl);

            if (curl_errno($curl)) {
                throw new TechnonextpayException('cURL Error: ' . curl_error($curl), 0, null);
            }

            $httpCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
            if ($httpCode >= 400) {
                throw new TechnonextpayException("HTTP Error: $httpCode", 0, null);
            }

            $decodedResponse = json_decode($response);
            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new TechnonextpayException('Invalid JSON response from API', 0, null);
            }

            return $decodedResponse;

        } catch (TechnonextpayException $e) {
            $this->log("Exception in Technonextpay->getHttpResponse: " . $e->getMessage());
            throw $e;
        } finally {
            if ($curl) {
                curl_close($curl);
            }
        }
    }

     
    /**
     * This function is used to create log and make directory if not exist.
     * @param  mixed $log_msg
     * @return void
     */
    public function log($log_msg)
    {

        try {
            #file_put_contents takes care of opening the file, writing the contents, and closing the file.
            $log_file_data = $this->conf->log_path . '/Technonextpay-plugin.log';
            $log_msg = gmdate('Y-m-d H:i:s') . " TechnonextPlugin: " . $log_msg;

            if (!file_exists($this->conf->log_path)) {
                mkdir($this->conf->log_path, 0755, true);
            }

            file_put_contents($log_file_data, $log_msg . "\n", FILE_APPEND);
        } # Catching TechnonextpayException custom exception and throwing it to TechnonextpayException
        catch (TechnonextpayException | \BadMethodCallException | \ArgumentCountError | \InvalidArgumentException $e) {
            $this->log("Exception in Technonextpay->log" . ". \n" . $e->getMessage());
            throw new TechnonextpayException("Please check and resolve errors to make successful Technonextpay log", 0, $e);
        }
    }


    /**
     * Generates complete signature with all components
     *
     * @param string $payload The request body (JSON)
     * @param string $apiKey API key
     * @param string $merchantId Merchant ID
     * @param string $apiSecret API secret (signing key)
     * @return array Array containing signature and all components
     * @throws Exception If signature generation fails
     */
    private function generateSignature(
        string $payload,
        string $apiKey,
        string $merchantId,
        string $apiSecret
    ): array {
        try {
            // Generate digest from payload
            $generatedDigest = $this->computeDigest($payload);

            // Define headers to sign in order
            $headersToSign = [
                "timestamp",
                "host",
                "target",
                "merchant-id",
                "api-key",
                "digest",
            ];

            // Generate components
            $timestamp = $this->generateRfc1123Date();
            $host = $this->conf->api_endpoint;
            $target = "POST /p/service/api/payment/processing/payment-order";

            // Build signature components
            $signatureComponents = [
                "timestamp" => $timestamp,
                "host" => $host,
                "target" => $target,
                "merchant-id" => $merchantId,
                "api-key" => $apiKey,
                "digest" => $generatedDigest,
            ];

            // Generate signature
            $signature = $this->computeHttpSignature(
                $headersToSign,
                $signatureComponents,
                $apiSecret
            );

            // Return the signature and other components for use
            return [
                "host" => $host,
                "target" => $target,
                "timestamp" => $timestamp,
                "digest" => $generatedDigest,
                "signature" => $signature,
            ];
        } catch (Exception $error) {
            error_log("generateSignature failed: " . $error->getMessage());
            throw $error;
        }
    }

    /**
     * Generates RFC 1123 formatted date string (GMT)
     * Format: "Day, DD Mon YYYY HH:MM:SS GMT"
     *
     * @return string The formatted RFC 1123 date string
     */
    private function generateRfc1123Date(): string
    {
        return gmdate('D, d M Y H:i:s \G\M\T');
    }

    /**
     * Computes a SHA-256 digest of the input data and returns it in the format "SHA-256=<base64>"
     * This mirrors the Java implementation's behavior
     *
     * @param string $data The input string to hash
     * @return string The formatted digest string
     * @throws Exception If hash computation fails
     */
    private function computeDigest(string $data): string
    {
        try {
            // Compute SHA-256 hash
            $hashBytes = hash('sha256', $data, true);
            
            if ($hashBytes === false) {
                throw new Exception('SHA-256 hash computation failed');
            }
            
            // Convert hash to base64
            $base64Hash = base64_encode($hashBytes);
            
            // Return formatted result
            return sprintf('SHA-256=%s', $base64Hash);
        } catch (Exception $error) {
            error_log("SHA-256 algorithm not available: " . $error->getMessage());
            throw new Exception("Required cryptographic algorithm not available");
        }
    }

    /**
     * Computes HTTP signature using HMAC-SHA256
     *
     * @param array $headersToSign Array of header names to sign
     * @param array $signatureComponents Map of header names to values
     * @param string $password Secret key for HMAC
     * @return string The base64-encoded signature
     * @throws Exception If signature computation fails
     */
    private function computeHttpSignature(
        array $headersToSign,
        array $signatureComponents,
        string $apiSecret
    ): string {
        try {
            $signingBase = $this->buildSigningBase($headersToSign, $signatureComponents);
            $hmacSignature = $this->generateHmacSignature($signingBase, $apiSecret);
            return $hmacSignature;
        } catch (Exception $error) {
            error_log("Failed to compute HTTP signature: " . $error->getMessage());
            throw new Exception("Failed to generate message signature.");
        }
    }

    /**
     * Generates HMAC-SHA256 signature
     *
     * @param string $signingBase The base string to sign
     * @param string $secretKey Secret key for HMAC
     * @return string The base64-encoded signature
     * @throws Exception If signature generation fails
     */
    private function generateHmacSignature(string $signingBase, string $apiSecret): string
    {
        try {
            // Generate HMAC-SHA256 signature
            $signatureBytes = hash_hmac('sha256', $signingBase, $apiSecret, true);
            
            if ($signatureBytes === false) {
                throw new Exception('HMAC-SHA256 signature generation failed');
            }
            
            // Convert to base64
            $base64Signature = base64_encode($signatureBytes);
            
            return $base64Signature;
        } catch (Exception $error) {
            error_log("HMAC-SHA256 generation failed: " . $error->getMessage());
            throw new Exception("Failed to generate HMAC-SHA256 signature");
        }
    }

    /**
     * Builds the signing base string from headers
     * Format: "header1: value1\nheader2: value2"
     *
     * @param array $headersToSign Array of header names
     * @param array $signatureComponents Map of header names to values
     * @return string The signing base string
     */
    private function buildSigningBase(array $headersToSign, array $signatureComponents): string
    {
        $parts = [];
        
        foreach ($headersToSign as $header) {
            $headerKey = $header; // Keep the case from the array
            if (isset($signatureComponents[$headerKey])) {
                $parts[] = strtolower($header) . ': ' . $signatureComponents[$headerKey];
            }
        }
        
        return implode("\n", $parts);
    }

    
}
